动态数组，栈，队列 => 底层依赖静态数组，靠resize解决固定容量问题
链表 => 真正的动态数据结构

数据存储在节点(Node)中
class Node {
  E e;
  Node next;    next负责指向下一个节点
}
数组是开一段连续的存储空间，链表中的每一个元素都占一个空间(分散的)，元素之间的联系靠next维持
node1 -> node2 -> node3 -> null 链表中的最后一个节点的next指向null

优点：真正的动态存储
缺点：没有随机访问的能力，但适合索引没有语义的情况

添加元素：必须先指向节点的下一个节点才能让新节点加入

为链表设置虚拟头节点：为了让所有节点都有前一个节点
dummyHead(null) -> head(对用户的第一个节点，索引是0) -> ... -> null

复杂度分析：
  添加操作：o(n)
    addLast()     o(n)
    addFirst()    o(1)
    add()         o(n/2)
  删除操作：o(n)
    removeLast()  o(n)
    removeFirst() o(1)
    remove()      o(n/2)
  查找操作：o(n)
    get()         o(n/2)
    getFirst()    o(1)
    getLast()     o(n)
    contains()    o(n)
  改值操作：o(n)
    set()         o(n)

链表适合的场景：
  只对链表头操作（添加、删除、查找）-> o(1)
  不对特定位置改值
  需要动态分配空间

因为对链表头的操作都是o(1)复杂度，所以适合实现stack结构，优化了数组实现的动态扩容
并不需要在扩容时进行复制操作

使用链表实现队列
head指向链表第一个元素，tail指向链表最后一个元素
e1 -> e2 -> e3 -> e4 -> e5 -> e6 -> e7 -> NULL
head（出队）                         tail（入队）
